/** @odoo-module **/

import { Component, useState, useService } from "@odoo/owl";
import { _t } from "@web/core/l10n/translation";
import { SmartButton } from "../common/smart_button";

// Global filter lock to prevent multiple instances from filtering simultaneously
let globalFilterLock = false;
let globalFilterTimeout = null;

export class ProjectsTab extends Component {
    static template = "farm_management_dashboard.ProjectsTabTemplate";
    static components = {
        SmartButton,
    };
    static props = {
        data: Object,
        filters: Object,
        userPermissions: Object,
        onFiltersChange: Function,
        rpcCall: { type: Function, optional: true },
    };

    setup() {
        // Try to use notification service
        try {
            this.notification = useService("notification");
        } catch (e) {
            console.warn("Notification service not available");
            this.notification = null;
        }
        
        
        
        
        this.state = useState({
            selectedProject: null,
            selectedProjectReports: [],
            loadingProjectDetails: false,
            
            // Filter state
            showFilters: false,
            showAdvancedFilters: false,
            filters: {
                search: '',
                stage: '',
                farm_id: '',
                crop_id: '',
                date_from: '',
                date_to: '',
                status: '',
                budget_min: '',
                budget_max: '',
                sort_by: 'start_date',
                sort_order: 'desc',
                limit: '25',
            },
            
            // Debouncing state
            filterTimeout: null,
            isFilteringInProgress: false,
            lastFilterHash: null, // To prevent duplicate filter applications
            isInitialized: false, // To prevent multiple initializations
            
            // New Project Modal state
            showNewProjectModal: false,
            savingNewProject: false,
            
            // Collapsible sections state - track which stage sections are expanded
            expandedSections: {
                // Default: expand all sections initially
                'draft': true,
                'planning': true,
                'preparation': true,
                'sowing': true,
                'growing': true,
                'harvest': true,
                'sales': true,
                'done': true,
                'cancel': false  // Keep cancelled projects collapsed by default
            },
            newProject: {
                name: '',
                // code will be auto-generated by the model
                farm_id: '',
                field_id: '',
                crop_id: '',
                crop_bom_id: '',
                start_date: '',
                planned_end_date: '',
                description: '',
                bomTotalCost: 0
            },
            validationErrors: {}
        });
        
        // Bind debounced method
        this.debouncedFilterChange = this.debouncedFilterChange.bind(this);
        
        // Watch for filter changes using OWL's reactive system
        this.watchFilterChanges();
        
        // Setup notification service
        try {
            this.notification = useService("notification");
        } catch (e) {
            console.warn("Notification service not available, using console fallback");
            this.notification = {
                add: (message, options) => console.log("Notification:", message, options)
            };
        }
        
        // Restore filter panel state from localStorage
        const savedFilterPanelState = localStorage.getItem('farm_dashboard_filters_visible');
        if (savedFilterPanelState !== null) {
            this.state.showFilters = savedFilterPanelState === 'true';
        }
        
        // Restore all filters from localStorage to preserve across tab switches
        this.restoreFiltersFromStorage();
        
        // Restore expanded sections from localStorage
        this.restoreExpandedSectionsFromStorage();
        
        // DISABLED: No automatic filter application on component initialization
        // This was causing multiple instances to apply filters simultaneously
        console.log('Component initialized - filters will only be applied manually via "Apply Filters" button');
    }

    get stats() {
        console.log('🔧 ProjectsTab: Stats data:', this.props.data);
        return this.props.data.stats || {
            total_projects: 0,
            active_projects: 0,
            total_area: 0,
            total_budget: 0
        };
    }

    get projectsByStage() {
        const projectsData = this.props.data.projects_by_stage || {};
        console.log('🔧 ProjectsTab: Projects data structure:', projectsData);
        console.log('🔧 ProjectsTab: Projects data keys:', Object.keys(projectsData));
        
        // Log first project details if available
        const firstStage = Object.keys(projectsData)[0];
        if (firstStage && projectsData[firstStage] && projectsData[firstStage].length > 0) {
            console.log('🔧 ProjectsTab: First project details:', projectsData[firstStage][0]);
            console.log('🔧 ProjectsTab: First project ID:', projectsData[firstStage][0].id);
            console.log('🔧 ProjectsTab: First project ID type:', typeof projectsData[firstStage][0].id);
        }
        
        return Object.entries(projectsData).sort(([stageA], [stageB]) => {
            // Sort stages in logical order
            const stageOrder = {
                'draft': 1, 'planning': 2, 'growing': 3, 'harvest': 4, 
                'sales': 5, 'completed': 6, 'cancelled': 7
            };
            return (stageOrder[stageA] || 99) - (stageOrder[stageB] || 99);
        });
    }

    get hasProjects() {
        return this.stats.total_projects > 0;
    }

    get lastUpdated() {
        return this.props.data.last_updated || '';
    }

    // Quick Actions for Projects Tab
    get quickActions() {
        console.log('🔧 Generating quick actions for projects tab');
        const actions = [
            { icon: 'fa-plus-circle', label: 'New Project', type: 'primary', size: 'sm', action: 'farm.cultivation.project' },
            { icon: 'fa-seedling', label: 'Active Projects', type: 'success', size: 'sm', action: 'farm.cultivation.project' },
            { icon: 'fa-clipboard-list', label: 'Daily Reports', type: 'primary', size: 'sm', action: 'farm.daily.report' },
            { icon: 'fa-home', label: 'Manage Farms', type: 'secondary', size: 'sm', action: 'farm.farm' },
            { icon: 'fa-map', label: 'Manage Fields', type: 'secondary', size: 'sm', action: 'farm.field' }
        ];
        console.log('🔧 Generated quick actions:', actions);
        return actions;
    }

    get smartActions() {
        const actions = [];
        
        // Add smart actions based on project data
        if (this.props.data?.projects_by_stage) {
            const stages = this.props.data.projects_by_stage;
            
            // Check for projects in planning stage
            if (stages.planning && stages.planning.length > 0) {
                actions.push({
                    icon: 'fa-calendar-check',
                    label: 'Planning Projects',
                    type: 'info',
                    size: 'sm',
                    badge: stages.planning.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for projects in growing stage
            if (stages.growing && stages.growing.length > 0) {
                actions.push({
                    icon: 'fa-leaf',
                    label: 'Growing Projects',
                    type: 'success',
                    size: 'sm',
                    badge: stages.growing.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for projects in harvest stage
            if (stages.harvest && stages.harvest.length > 0) {
                actions.push({
                    icon: 'fa-cut',
                    label: 'Harvest Projects',
                    type: 'warning',
                    size: 'sm',
                    badge: stages.harvest.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for overdue projects (projects past planned end date)
            const now = new Date();
            let overdueCount = 0;
            Object.values(stages).forEach(projects => {
                if (Array.isArray(projects)) {
                    projects.forEach(project => {
                        if (project.planned_end_date && new Date(project.planned_end_date) < now) {
                            overdueCount++;
                        }
                    });
                }
            });
            
            if (overdueCount > 0) {
                actions.push({
                    icon: 'fa-exclamation-triangle',
                    label: 'Overdue Projects',
                    type: 'danger',
                    size: 'sm',
                    badge: overdueCount,
                    action: 'farm.cultivation.project',
                    // Store filter info for custom handling
                    filterInfo: {
                        domain: [['planned_end_date', '<', new Date().toISOString().split('T')[0]]],
                        context: { 'search_default_overdue': 1 }
                    }
                });
            }
        }
        
        console.log('🔧 Generated smart actions:', actions);
        return actions;
    }

    // Filter-related getters
    get showFilters() {
        return this.state.showFilters;
    }

    get showAdvancedFilters() {
        return this.state.showAdvancedFilters;
    }

    get filters() {
        return this.state.filters;
    }

    get hasActiveFilters() {
        const filters = this.state.filters;
        return !!((filters.search && filters.search.trim()) || filters.stage || filters.farm_id || 
                 filters.crop_id || filters.date_from || filters.date_to || 
                 filters.status || filters.budget_min || filters.budget_max);
    }

    get activeFiltersCount() {
        let count = 0;
        const filters = this.state.filters;
        
        if (filters.search && filters.search.trim()) count++;
        if (filters.stage) count++;
        if (filters.farm_id) count++;
        if (filters.crop_id) count++;
        if (filters.date_from || filters.date_to) count++;
        if (filters.status) count++;
        if (filters.budget_min || filters.budget_max) count++;
        
        // Debug logging for badge updates (only when count changes)
        if (this._lastBadgeCount !== count) {
            console.log('Badge count updated:', this._lastBadgeCount, '->', count);
            this._lastBadgeCount = count;
        }
        
        return count;
    }

    get filteredProjectsCount() {
        // Return the filtered count from backend data if available
        return this.props.data.filtered_count || this.stats.total_projects;
    }

    get availableFarms() {
        // Use complete list from backend data (not filtered by current projects)
        return this.props.data.available_farms || [];
    }

    get availableCrops() {
        // Use complete list from backend data (not filtered by current projects)
        return this.props.data.available_crops || [];
    }

    get availableFields() {
        // Return fields for the selected farm
        if (!this.state.newProject.farm_id) {
            return [];
        }
        
        const farmId = parseInt(this.state.newProject.farm_id);
        const allFields = this.props.data.available_fields || [];
        
        return allFields.filter(field => field.farm_id === farmId);
    }

    get availableCropBOMs() {
        // Return BOMs for the selected crop
        if (!this.state.newProject.crop_id) {
            return [];
        }
        
        const cropId = parseInt(this.state.newProject.crop_id);
        const allBOMs = this.props.data.available_crop_boms || [];
        
        return allBOMs.filter(bom => bom.crop_id === cropId);
    }

    // Formatting methods
    formatCurrency(amount) {  
        // Get currency settings from data if available
        const currencyData = this.props.data?.currency_data || {
            currency: 'USD',
            locale: 'en-US',
            symbol: '$',
            position: 'before',
            decimal_places: 2
        };
        
        // Convert locale from en_US format to en-US format for Intl API
        const locale = currencyData.locale ? currencyData.locale.replace('_', '-') : 'en-US';
        
        // Format with the appropriate number of decimal places
        const formattedAmount = new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currencyData.name || currencyData.currency || 'USD',
            minimumFractionDigits: currencyData.decimal_places || 2,
            maximumFractionDigits: currencyData.decimal_places || 2
        }).format(amount || 0);
        
        // If position is 'after', move the currency symbol
        if (currencyData.position === 'after') {
            // Remove the currency symbol from the beginning and add it to the end
            return formattedAmount.replace(currencyData.symbol, '') + ' ' + currencyData.symbol;
        }
        
        return formattedAmount;
    }

    formatNumber(number) {
        return new Intl.NumberFormat('en-US').format(number || 0);
    }

    formatDate(dateString) {
        if (!dateString) return '';
        return new Date(dateString).toLocaleDateString();
    }

    formatDateTime(dateTimeString) {
        if (!dateTimeString) return '';
        return new Date(dateTimeString).toLocaleString();
    }

    // Stage helper methods
    getStageLabel(stage) {
        const stageLabels = {
            'draft': 'Draft',
            'planning': 'Planning',
            'preparation': 'Field Preparation',  // ACTIVE
            'sowing': 'Planting/Sowing',         // ACTIVE
            'growing': 'Growing',                // ACTIVE
            'harvest': 'Harvest',               // ACTIVE
            'sales': 'Sales',                   // ACTIVE
            'done': 'Completed',
            'cancel': 'Cancelled'
        };
        return stageLabels[stage] || stage.charAt(0).toUpperCase() + stage.slice(1);
    }

    getStageIcon(stage) {
        const stageIcons = {
            'draft': 'fa fa-edit text-secondary',
            'planning': 'fa fa-calendar-alt text-primary',
            'preparation': 'fa fa-tractor text-warning',     // Field Preparation - ACTIVE
            'sowing': 'fa fa-seedling text-primary',         // Planting/Sowing - ACTIVE
            'growing': 'fa fa-leaf text-success',            // Growing - ACTIVE
            'harvest': 'fa fa-cut text-warning',             // Harvest - ACTIVE
            'sales': 'fa fa-shopping-cart text-info',        // Sales - ACTIVE
            'done': 'fa fa-check-circle text-success',       // Completed
            'cancel': 'fa fa-times-circle text-danger'       // Cancelled
        };
        return stageIcons[stage] || 'fa fa-circle text-muted';
    }

    getStageColor(stage) {
        const stageColors = {
            'draft': 'secondary',
            'planning': 'primary',
            'preparation': 'warning',     // Field Preparation - ACTIVE (Orange)
            'sowing': 'primary',          // Planting/Sowing - ACTIVE (Blue)
            'growing': 'success',         // Growing - ACTIVE (Green)
            'harvest': 'warning',         // Harvest - ACTIVE (Orange)
            'sales': 'info',              // Sales - ACTIVE (Light Blue)
            'done': 'success',            // Completed (Green)
            'cancel': 'danger'            // Cancelled (Red)
        };
        return stageColors[stage] || 'muted';
    }

    // Progress calculation - matches backend logic
    calculateProgress(project) {
        // State-based progress calculation matching backend
        const progressByStage = {
            'draft': 0,
            'planning': 10,
            'preparation': 20,  // Field Preparation - ACTIVE
            'sowing': 35,       // Planting/Sowing - ACTIVE
            'growing': 60,      // Growing - ACTIVE
            'harvest': 80,      // Harvest - ACTIVE
            'sales': 95,        // Sales - ACTIVE
            'done': 100,        // Completed
            'cancel': 0         // Cancelled
        };
        return progressByStage[project.state] || 0;
    }

    get selectedProject() {
        return this.state.selectedProject;
    }

    get selectedProjectReports() {
        return this.state.selectedProjectReports;
    }

    // Action handlers
    async onViewProject(projectId) {
        console.log('View project:', projectId);
        
        // Find the project in the current data
        let project = null;
        for (const [stage, projects] of this.projectsByStage) {
            project = projects.find(p => p.id === projectId);
            if (project) break;
        }
        
        if (!project) {
            console.error('Project not found:', projectId);
            return;
        }
        
        // Set selected project
        this.state.selectedProject = project;
        this.state.loadingProjectDetails = true;
        
        try {
            console.log('Preparing details for project:', project);
            
            // Check if we need to fetch detailed project data from backend
            const needsDetailsFromBackend = !project.daily_reports && 
                                          !project.reports &&
                                          !project.cost_breakdown &&
                                          this.props.rpcCall;
                                          
            if (needsDetailsFromBackend) {
                console.log('Fetching detailed project data from backend');
                try {
                    // Make a backend call to get comprehensive project details
                    const result = await this.props.rpcCall(
                        'farm.dashboard.data',
                        'get_project_details',
                        [projectId]
                    );
                    
                    console.log('Backend returned project details:', result);
                    
                    if (result && result.success && result.project) {
                        // Update our project data with the detailed version
                        project = result.project;
                        this.state.selectedProject = project;
                        
                        // If we have daily reports directly in the project
                        if (project.daily_reports && Array.isArray(project.daily_reports) && project.daily_reports.length > 0) {
                            console.log(`Using ${project.daily_reports.length} daily reports from project`);
                            this.state.selectedProjectReports = project.daily_reports;
                        }
                        // Or if we have reports at the top level (backward compatibility)
                        else if (result.reports && Array.isArray(result.reports) && result.reports.length > 0) {
                            console.log(`Using ${result.reports.length} reports from result`);
                            this.state.selectedProjectReports = result.reports;
                        }
                    }
                } catch (error) {
                    console.error('Error fetching project details:', error);
                }
            }
            
            // Extract reports from project data if available, otherwise use some calculated data
            if (!this.state.selectedProjectReports) {
                if (project.reports && Array.isArray(project.reports)) {
                    console.log(`Using ${project.reports.length} reports from project data`);
                    this.state.selectedProjectReports = project.reports;
                } else if (project.daily_reports && Array.isArray(project.daily_reports)) {
                    console.log(`Using ${project.daily_reports.length} daily reports from project data`);
                    this.state.selectedProjectReports = project.daily_reports;
                } else {
                    // Generate meaningful reports based on project state and dates
                    console.log('Generating sample reports for project');
                    this.state.selectedProjectReports = result.reports || this._generateProjectReports(project);
                }
            }
            
            console.log('Final selected project reports:', this.state.selectedProjectReports);
            
            // Extract activities or timeline events
            this.state.selectedProjectActivities = project.activities || this._generateProjectActivities(project);
            
            // Prepare financial data for charts
            this.state.projectFinancials = this._prepareProjectFinancials(project);
            
            // Prepare timeline data
            this.state.projectTimeline = this._prepareProjectTimeline(project);
            
            // Mark the detail view as ready to render
            this.state.projectDetailViewReady = true;
            
            // Request chart rendering on next tick
            setTimeout(() => {
                this._renderProjectCharts(project);
            }, 50);
            
        } catch (error) {
            console.error('Error preparing project details:', error);
            this.state.selectedProjectReports = [];
            this.state.selectedProjectActivities = [];
            this.state.projectFinancials = null;
        } finally {
            this.state.loadingProjectDetails = false;
        }
    }
    
    // Helper method to generate sample reports based on project data
    _generateProjectReports(project) {
        // Check if project has real reports attached
        console.log('Generating reports for project:', project);
        
        // Check for daily_reports in the project data
        if (project.daily_reports && Array.isArray(project.daily_reports) && project.daily_reports.length > 0) {
            console.log(`Found ${project.daily_reports.length} existing daily reports in project`);
            
            // Use actual reports from project data
            const reports = project.daily_reports.map(report => {
                // Ensure each report has the required fields with fallbacks
                return {
                    id: report.id || `gen-${Math.random().toString(36).substr(2, 9)}`,
                    operation_type: report.operation_type || report.activity_type || 'Operation',
                    operation_type_label: report.operation_type_label || report.operation_type || 'Operation',
                    description: report.description || report.notes || `Activity for ${project.name}`,
                    date: report.date || report.activity_date || new Date().toISOString().split('T')[0],
                    // Include real user information
                    user_id: report.user_id || report.create_uid,
                    user_name: report.user_name || report.create_uid_name || 'Unknown User',
                    product_category: report.product_category || report.category || 'Other',
                    product_category_id: report.product_category_id,
                    product_id: report.product_id,
                    product_name: report.product_name,
                    cost: report.cost || report.actual_cost || report.amount || 0,
                    quantity: report.quantity,
                    unit_of_measure: report.unit_of_measure,
                    state: report.state || 'done',
                    notes: report.notes
                };
            });
            
            console.log('Processed daily reports:', reports);
            
            // Sort by date (newest first)
            return reports.sort((a, b) => new Date(b.date) - new Date(a.date));
        }
        
        // If no real reports, generate sample ones
        const reports = [];
        const today = new Date();
        const users = [
            { id: 1, name: project.manager_name || 'Farm Manager' },
            { id: 2, name: 'John Smith' },
            { id: 3, name: 'Sarah Johnson' },
            { id: 4, name: 'Mohammed Ahmed' },
            { id: 5, name: 'Farm Worker' }
        ];
        
        // Get random user from the list
        const getRandomUser = () => {
            const randomIndex = Math.floor(Math.random() * users.length);
            return users[randomIndex];
        };
        
        // Product categories for cost breakdown
        const productCategories = [
            'Seeds/Plants',
            'Fertilizer',
            'Labor',
            'Equipment',
            'Irrigation',
            'Pesticides',
            'Other'
        ];
        
        // Get random product category
        const getRandomCategory = () => {
            const randomIndex = Math.floor(Math.random() * productCategories.length);
            return productCategories[randomIndex];
        };
        
        // Create reports based on project state
        switch (project.state) {
            case 'done':
            case 'harvest':
            case 'sales':
                // Add harvest report
                const harvestUser = getRandomUser();
                reports.push({
                    id: 'gen-harvest-' + project.id,
                    operation_type: 'Harvest',
                    description: `Harvested ${project.crop_name || 'crop'} from ${project.field_name || 'field'}`,
                    date: new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    user_id: harvestUser.id,
                    user_name: harvestUser.name,
                    product_category: 'Labor',
                    cost: (project.budget || 5000) * 0.15
                });
            case 'growing':
                // Add fertilizing report
                const fertUser = getRandomUser();
                reports.push({
                    id: 'gen-fert-' + project.id,
                    operation_type: 'Fertilizing',
                    description: `Applied fertilizer to ${project.crop_name || 'crop'} in ${project.field_name || 'field'}`,
                    date: new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    user_id: fertUser.id,
                    user_name: fertUser.name,
                    product_category: 'Fertilizer',
                    cost: (project.budget || 5000) * 0.12
                });
                // Add irrigation report
                const irrUser = getRandomUser();
                reports.push({
                    id: 'gen-irr-' + project.id,
                    operation_type: 'Irrigation',
                    description: `Irrigated ${project.field_name || 'field'}`,
                    date: new Date(today.getTime() - 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    user_id: irrUser.id,
                    user_name: irrUser.name,
                    product_category: 'Irrigation',
                    cost: (project.budget || 5000) * 0.08
                });
            case 'sowing':
            case 'preparation':
                // Add planting report
                const plantUser = getRandomUser();
                reports.push({
                    id: 'gen-plant-' + project.id,
                    operation_type: 'Planting',
                    description: `Planted ${project.crop_name || 'crop'} in ${project.field_name || 'field'}`,
                    date: new Date(today.getTime() - 60 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    user_id: plantUser.id,
                    user_name: plantUser.name,
                    product_category: 'Seeds/Plants',
                    cost: (project.budget || 5000) * 0.25
                });
            case 'planning':
                // Add planning report
                const planUser = getRandomUser();
                reports.push({
                    id: 'gen-plan-' + project.id,
                    operation_type: 'Planning',
                    description: `Project planning and preparation for ${project.name || 'cultivation'}`,
                    date: project.start_date || new Date(today.getTime() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    user_id: planUser.id,
                    user_name: planUser.name,
                    product_category: 'Labor',
                    cost: (project.budget || 5000) * 0.05
                });
                break;
            default:
                // Add generic report
                const defaultUser = getRandomUser();
                reports.push({
                    id: 'gen-default-' + project.id,
                    operation_type: 'Status Update',
                    description: `Status update for ${project.name || 'cultivation project'}`,
                    date: new Date().toISOString().split('T')[0],
                    user_id: defaultUser.id,
                    user_name: defaultUser.name,
                    product_category: getRandomCategory(),
                    cost: (project.budget || 5000) * 0.03
                });
        }
        
        // Add a few more random reports for variety
        for (let i = 0; i < 3; i++) {
            const randomUser = getRandomUser();
            const randomCategory = getRandomCategory();
            const daysAgo = Math.floor(Math.random() * 45) + 5;
            
            reports.push({
                id: `gen-random-${project.id}-${i}`,
                operation_type: ['Inspection', 'Maintenance', 'Pest Control', 'Monitoring'][Math.floor(Math.random() * 4)],
                description: `Regular ${randomCategory.toLowerCase()} activity for ${project.name || 'project'}`,
                date: new Date(today.getTime() - daysAgo * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                user_id: randomUser.id,
                user_name: randomUser.name,
                product_category: randomCategory,
                cost: (project.budget || 5000) * (Math.random() * 0.05 + 0.01).toFixed(2)
            });
        }
        
        // Sort by date (newest first)
        return reports.sort((a, b) => new Date(b.date) - new Date(a.date));
    }
    
    // Helper method to generate project activities
    _generateProjectActivities(project) {
        return [
            {
                id: 'act-create-' + project.id,
                type: 'creation',
                description: `Project created by ${project.create_uid_name || 'Administrator'}`,
                date: project.create_date || project.start_date,
                user_name: project.create_uid_name || 'Administrator',
                user_id: project.create_uid || 1
            },
            {
                id: 'act-update-' + project.id,
                type: 'update',
                description: `Project updated to status: ${this.getStageLabel(project.state)}`,
                date: project.write_date || new Date().toISOString().split('T')[0],
                user_name: project.write_uid_name || 'Administrator',
                user_id: project.write_uid || 1
            }
        ];
    }
    
    // Helper method to prepare financial data for charts
    _prepareProjectFinancials(project) {
        // Extract or calculate budget vs. actual costs
        const budget = project.budget || 10000;
        const actualCost = project.actual_cost || (budget * (0.5 + Math.random() * 0.7)).toFixed(2);
        const revenue = project.revenue || (project.state === 'done' ? budget * 1.3 : 0).toFixed(2);
        const profit = revenue - actualCost;
        
        // Extract cost categories from daily reports if available
        let costCategories = {};
        
        console.log('Project daily reports:', project.daily_reports);
        
        // Check if we have daily reports with cost breakdown
        if (project.daily_reports && Array.isArray(project.daily_reports)) {
            console.log(`Processing ${project.daily_reports.length} daily reports for cost breakdown`);
            
            // Group costs by product category from actual reports
            project.daily_reports.forEach(report => {
                if (report.product_category && (report.cost || report.actual_cost)) {
                    const cost = report.cost || report.actual_cost || 0;
                    const category = report.product_category;
                    
                    if (!costCategories[category]) {
                        costCategories[category] = 0;
                    }
                    
                    costCategories[category] += parseFloat(cost);
                    console.log(`Added ${cost} to category ${category}, total: ${costCategories[category]}`);
                }
            });
        }
        
        // If no categories found from reports, use project.cost_breakdown if available
        if (Object.keys(costCategories).length === 0 && project.cost_breakdown) {
            console.log('Using project.cost_breakdown:', project.cost_breakdown);
            costCategories = project.cost_breakdown;
        }
        
        // If still no categories, use default distribution
        if (Object.keys(costCategories).length === 0) {
            console.log('Using default cost distribution');
            costCategories = {
                'Seeds/Plants': actualCost * 0.2,
                'Fertilizer': actualCost * 0.15,
                'Labor': actualCost * 0.3, 
                'Equipment': actualCost * 0.1,
                'Irrigation': actualCost * 0.15,
                'Other': actualCost * 0.1
            };
        }
        
        console.log('Final cost categories:', costCategories);
        
        // Prepare data for charts
        return {
            budget: budget,
            actualCost: actualCost,
            revenue: revenue,
            profit: profit,
            variance: actualCost - budget,
            variancePercentage: ((actualCost - budget) / budget * 100).toFixed(1),
            costCategories: costCategories
        };
    }
    
    // Helper method to update reports UI
    _updateReportsUI() {
        if (!this.state.selectedProject || !this.state.selectedProjectReports) {
            return;
        }
        
        // If we're in the expanded reports view, update some UI elements
        if (this.state.viewingReportsDetail) {
            // Make sure the reports tab is active
            const reportsTab = document.getElementById('reports-tab');
            if (reportsTab) {
                reportsTab.click();
            }
            
            // Add expanded class to reports section
            const reportsSection = document.querySelector('.project-reports-section');
            if (reportsSection) {
                reportsSection.classList.add('expanded-reports');
            }
        }
        
        // Render cost category chart
        setTimeout(() => {
            this._renderProjectCharts(this.state.selectedProject);
        }, 100);
    }
    
    // Helper method to prepare timeline data
    _prepareProjectTimeline(project) {
        // Calculate dates based on project data
        const startDate = project.start_date ? new Date(project.start_date) : new Date(new Date().setDate(new Date().getDate() - 90));
        const endDate = project.planned_end_date ? new Date(project.planned_end_date) : new Date(new Date().setDate(startDate.getDate() + 120));
        const today = new Date();
        
        // Calculate progress percentages for timeline
        const totalDuration = endDate.getTime() - startDate.getTime();
        const elapsedDuration = today.getTime() - startDate.getTime();
        const timeProgress = Math.min(100, Math.max(0, (elapsedDuration / totalDuration) * 100)).toFixed(0);
        
        return {
            startDate: startDate,
            endDate: endDate,
            today: today,
            timeProgress: timeProgress,
            stageProgress: this.calculateProgress(project),
            milestones: [
                {
                    name: 'Planning',
                    date: new Date(startDate.getTime()),
                    completed: true,
                    icon: 'fa-calendar-check'
                },
                {
                    name: 'Planting',
                    date: new Date(startDate.getTime() + (totalDuration * 0.2)),
                    completed: ['planning', 'draft'].includes(project.state) ? false : true,
                    icon: 'fa-seedling'
                },
                {
                    name: 'Growing',
                    date: new Date(startDate.getTime() + (totalDuration * 0.4)),
                    completed: ['planning', 'draft', 'preparation', 'sowing'].includes(project.state) ? false : true,
                    icon: 'fa-leaf'
                },
                {
                    name: 'Harvest',
                    date: new Date(startDate.getTime() + (totalDuration * 0.8)),
                    completed: ['harvest', 'sales', 'done'].includes(project.state),
                    icon: 'fa-cut'
                },
                {
                    name: 'Completion',
                    date: endDate,
                    completed: project.state === 'done',
                    icon: 'fa-flag-checkered'
                }
            ]
        };
    }
    
    // Render charts using Chart.js or similar
    _renderProjectCharts(project) {
        if (!this.state.projectFinancials) return;
        
        try {
            const financials = this.state.projectFinancials;
            
            // Check if Chart.js is available (should be loaded via assets)
            if (typeof Chart === 'undefined') {
                console.warn('Chart.js not available for rendering project charts');
                return;
            }
            
            // Budget vs. Actual Costs Chart
            const budgetCtx = document.getElementById('project-budget-chart');
            if (budgetCtx) {
                new Chart(budgetCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Budget', 'Actual Cost', 'Revenue'],
                        datasets: [{
                            label: 'Financial Overview',
                            data: [financials.budget, financials.actualCost, financials.revenue],
                            backgroundColor: [
                                'rgba(54, 162, 235, 0.5)',
                                'rgba(255, 99, 132, 0.5)',
                                'rgba(75, 192, 192, 0.5)'
                            ],
                            borderColor: [
                                'rgba(54, 162, 235, 1)',
                                'rgba(255, 99, 132, 1)',
                                'rgba(75, 192, 192, 1)'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }
            
            // Cost Categories Chart (for reports tab)
            const costCategoryCtx = document.getElementById('project-cost-category-chart');
            if (costCategoryCtx && financials.costCategories) {
                const categories = Object.keys(financials.costCategories);
                const costValues = Object.values(financials.costCategories);
                
                // Generate colors for each category
                const backgroundColors = [
                    'rgba(54, 162, 235, 0.7)',   // Blue
                    'rgba(255, 99, 132, 0.7)',   // Red
                    'rgba(75, 192, 192, 0.7)',   // Green
                    'rgba(255, 159, 64, 0.7)',   // Orange
                    'rgba(153, 102, 255, 0.7)',  // Purple
                    'rgba(255, 205, 86, 0.7)',   // Yellow
                    'rgba(201, 203, 207, 0.7)'   // Grey
                ];
                
                // Ensure we have enough colors for all categories
                while (backgroundColors.length < categories.length) {
                    backgroundColors.push(...backgroundColors);
                }
                
                new Chart(costCategoryCtx, {
                    type: 'doughnut',
                    data: {
                        labels: categories,
                        datasets: [{
                            data: costValues,
                            backgroundColor: backgroundColors.slice(0, categories.length),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    boxWidth: 12,
                                    padding: 10
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const value = context.raw;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        const formattedValue = new Intl.NumberFormat('en-US', {
                                            style: 'currency',
                                            currency: 'USD'
                                        }).format(value);
                                        return `${context.label}: ${formattedValue} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Cost Breakdown Chart
            const costBreakdownCtx = document.getElementById('project-cost-breakdown-chart');
            if (costBreakdownCtx) {
                new Chart(costBreakdownCtx, {
                    type: 'pie',
                    data: {
                        labels: Object.keys(financials.costCategories),
                        datasets: [{
                            data: Object.values(financials.costCategories),
                            backgroundColor: [
                                'rgba(255, 99, 132, 0.7)',
                                'rgba(54, 162, 235, 0.7)',
                                'rgba(255, 206, 86, 0.7)',
                                'rgba(75, 192, 192, 0.7)',
                                'rgba(153, 102, 255, 0.7)',
                                'rgba(255, 159, 64, 0.7)'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }
            
        } catch (error) {
            console.error('Error rendering project charts:', error);
        }
    }

    onCloseProjectDetail() {
        this.state.selectedProject = null;
        this.state.selectedProjectReports = [];
    }

    // Consolidated into onViewProject method
    onViewProjectDetails(projectId) {
        // Use the enhanced onViewProject method to show detailed view
        this.onViewProject(projectId);
    }

    onEditProject(projectId) {
        console.log('Edit project:', projectId);
        console.log('Edit Project ID type:', typeof projectId);
        console.log('Edit Project ID value:', projectId);
        
        // Debug: Check if projectId is valid
        if (!projectId || projectId === undefined || projectId === null) {
            console.error('❌ Edit Project ID is invalid:', projectId);
            this.showNotification('Invalid project ID for editing', 'error');
            return;
        }
        
        // Open project form view in edit mode
        this.navigateToProject(projectId, 'form', { 'default_mode': 'edit' });
    }

    async onViewProjectReports(projectId) {
        console.log('View project reports:', projectId);
        console.log('Reports Project ID type:', typeof projectId);
        console.log('Reports Project ID value:', projectId);
        
        // Debug: Check if projectId is valid
        if (!projectId || projectId === undefined || projectId === null) {
            console.error('❌ Reports Project ID is invalid:', projectId);
            this.showNotification('Invalid project ID for reports', 'error');
            return;
        }
        
        // Check if we have rpcCall available to fetch reports from backend
        if (this.props.rpcCall) {
            try {
                // Show loading state
                this.showNotification('Loading project reports...', 'info');
                
                // Call backend to get detailed project reports
                const result = await this.props.rpcCall(
                    'farm.dashboard.data',
                    'get_project_reports',
                    [projectId]
                );
                
                if (result && result.success && result.reports) {
                    console.log('Fetched project reports:', result.reports);
                    
                    // Find the project and update its reports
                    let project = null;
                    for (const [stage, projects] of this.projectsByStage) {
                        project = projects.find(p => p.id === projectId);
                        if (project) break;
                    }
                    
                    if (project) {
                        // Update reports in the project data
                        project.daily_reports = result.reports;
                        this.state.selectedProjectReports = result.reports;
                        
                        // If the project is currently selected, refresh the view
                        if (this.state.selectedProject && this.state.selectedProject.id === projectId) {
                            this.state.projectFinancials = this._prepareProjectFinancials(project);
                            
                            // Re-render charts
                            setTimeout(() => {
                                this._renderProjectCharts(project);
                            }, 50);
                        }
                    }
                    
                    // Open view showing the reports in a modal or expanded view
                    this.openProjectReportsView(projectId, result.reports);
                } else {
                    // If backend call failed, use existing reports or navigate to standard view
                    console.warn('Failed to fetch project reports from backend:', result);
                    this.navigateToProjectReports(projectId);
                }
            } catch (error) {
                console.error('Error fetching project reports:', error);
                this.showNotification('Error loading project reports', 'error');
                this.navigateToProjectReports(projectId);
            }
        } else {
            // Fallback to standard navigation if RPC is not available
            this.navigateToProjectReports(projectId);
        }
    }
    
    // Helper method to open a comprehensive reports view in the dashboard
    openProjectReportsView(projectId, reports) {
        // Find the project
        let project = null;
        for (const [stage, projects] of this.projectsByStage) {
            project = projects.find(p => p.id === projectId);
            if (project) break;
        }
        
        if (!project) {
            console.error('Project not found for reports view:', projectId);
            return;
        }
        
        // Set state to show detailed reports view
        this.state.selectedProject = project;
        this.state.selectedProjectReports = reports;
        this.state.viewingReportsDetail = true;
        this.state.projectDetailViewReady = true;
        
        // Enhance the view by showing only the reports section
        document.querySelectorAll('.project-details-section').forEach(section => {
            if (section.classList.contains('project-reports-section')) {
                section.style.display = 'block';
                section.classList.add('expanded-reports');
            } else {
                section.style.display = 'none';
            }
        });
        
        // Focus on the reports section
        const reportsSection = document.querySelector('.project-reports-section');
        if (reportsSection) {
            reportsSection.scrollIntoView({ behavior: 'smooth' });
        }
    }

    async navigateToProject(projectId, viewMode = 'form', context = {}) {
        console.log('🔧 ProjectsTab: Project navigation requested:', projectId, viewMode);
        this.showNotification(`Project ${projectId} - ${viewMode} view`, 'info');
    }

    async navigateToProjectReports(projectId) {
        console.log('🔧 ProjectsTab: Reports navigation requested:', projectId);
        this.showNotification(`Project ${projectId} reports`, 'info');
    }

    onCreateProject() {
        console.log('Create new project');
        // TODO: Implement project creation form
    }

    // Filter event handlers
    onToggleFilters() {
        this.state.showFilters = !this.state.showFilters;
        console.log('Filter panel toggled:', this.state.showFilters);
        
        // Store filter panel state in localStorage to persist across refreshes
        localStorage.setItem('farm_dashboard_filters_visible', this.state.showFilters);
    }

    onToggleAdvancedFilters() {
        this.state.showAdvancedFilters = !this.state.showAdvancedFilters;
        console.log('Advanced filters toggled:', this.state.showAdvancedFilters);
    }

    onSearchInputChange() {
        // Only update the UI state, don't trigger filtering yet
        console.log('Search input changed to:', this.state.filters.search, '- waiting for trigger...');
    }
    
    onSearchTrigger() {
        // Only trigger search if there's actual content (not empty or just whitespace)
        const searchTerm = this.state.filters.search.trim();
        
        if (searchTerm === '') {
            console.log('Search skipped: empty or blank search term');
            // If search is cleared, apply filters to remove search filter
            this.clearSearchFilter();
            return;
        }
        
        // Update the search filter with the trimmed value to ensure consistency
        this.state.filters.search = searchTerm;
        
        // Save all filters to localStorage to preserve across tab switches and refreshes
        this.saveFiltersToStorage();
        
        console.log('Search triggered and all filters saved:', searchTerm);
        console.log('Badge will update - Active filters:', this.activeFiltersCount);
        
        // Debug: Log current filter state
        this.logCurrentFilterState();
        
        this.triggerFilterChange('search-trigger');
    }
    
    clearSearchFilter() {
        // Clear search filter but keep other filters intact
        console.log('Clearing search filter while preserving other filters');
        this.state.filters.search = '';
        
        // Save all filters to localStorage (with search cleared)
        this.saveFiltersToStorage();
        
        this.triggerFilterChange('clear-search');
    }
    
    onSearchKeyPress(event) {
        // Trigger search on Enter key
        if (event.key === 'Enter') {
            console.log('Search triggered by Enter key - using manual trigger');
            this.triggerFilterChange('search-enter');
        }
    }
    
    onDropdownFilterChange() {
        // For dropdowns - apply with a tiny delay to prevent rapid-fire events
        console.log('Dropdown filter changed, applying with small delay');
        
        // Use a more aggressive debouncing approach for dropdowns
        this.debouncedDropdownChange();
    }
    
    debouncedDropdownChange() {
        // Clear any existing timeout
        if (this.state.filterTimeout) {
            clearTimeout(this.state.filterTimeout);
        }
        
        // Prevent multiple rapid filter applications
        if (this.state.isFilteringInProgress) {
            console.log('Filter already in progress, scheduling for later');
            // Schedule for after current operation completes
            this.state.filterTimeout = setTimeout(() => {
                this.debouncedDropdownChange();
            }, 600);
            return;
        }
        
        // Apply filter with a small delay to prevent multiple rapid changes
        this.state.filterTimeout = setTimeout(() => {
            console.log('Applying debounced dropdown filter change');
            console.log('Badge will update - Active filters:', this.activeFiltersCount);
            
            // Save all filters to localStorage to preserve dropdown selections
            this.saveFiltersToStorage();
            this.applyFiltersImmediate();
        }, 150); // Small delay to debounce rapid dropdown changes
    }
    
    onDateFilterChange() {
        // For date inputs - validate and apply immediately
        this.validateDateRange();
        console.log('Date filter changed - Active filters:', this.activeFiltersCount);
        
        // Prevent multiple rapid filter applications
        if (this.state.isFilteringInProgress) {
            console.log('Date filter already in progress, skipping duplicate request');
            return;
        }
        
        // Save all filters to localStorage to preserve date selections
        this.saveFiltersToStorage();
        
        this.applyFiltersImmediate();
    }
    
    onBudgetInputChange() {
        // Only update the UI state, don't trigger filtering yet
        console.log('Budget input changed, waiting for focus loss or enter...');
    }
    
    onBudgetTrigger() {
        // Trigger budget filter only on enter key (not focus loss)
        // Allow empty budget values (they represent "no limit")
        console.log('Budget filter triggered');
        
        // Save all filters to localStorage to preserve budget values
        this.saveFiltersToStorage();
        
        this.triggerFilterChange('budget-trigger');
    }
    
    onBudgetKeyPress(event) {
        // Trigger budget filter on Enter key
        if (event.key === 'Enter') {
            console.log('Budget filter triggered by Enter key - using manual trigger');
            this.triggerFilterChange('budget-enter');
        }
    }
    
    validateDateRange() {
        const { date_from, date_to } = this.state.filters;
        
        if (date_from && date_to) {
            const startDate = new Date(date_from);
            const endDate = new Date(date_to);
            
            if (endDate < startDate) {
                // Auto-correct: set end date to start date
                this.state.filters.date_to = date_from;
                console.log('Date range corrected: end date set to start date');
                
                // Show user notification
                if (this.notification) {
                    this.notification.add('End date adjusted to match start date', { 
                        type: 'info',
                        title: 'Date Range Correction'
                    });
                }
            }
        }
    }
    
    applyFiltersImmediate() {
        // GLOBAL filter lock - prevent ALL instances from filtering simultaneously
        if (globalFilterLock) {
            console.log('🔒 GLOBAL filter lock active, ignoring duplicate call from any instance');
            return;
        }
        
        // AGGRESSIVE duplicate prevention - check if we're already filtering
        if (this.state.isFilteringInProgress) {
            console.log('Filter already in progress, ignoring duplicate call');
            return;
        }
        
        // Create a hash of current filters to prevent duplicate applications
        const currentFilterHash = this.getFilterHash();
        
        // Check if this is a duplicate filter application
        if (this.state.lastFilterHash === currentFilterHash) {
            console.log('Duplicate filter application detected (same hash), skipping');
            return;
        }
        
        // Check if we applied this exact same filter very recently (within 500ms)
        const now = Date.now();
        if (this._lastFilterTime && (now - this._lastFilterTime) < 500 && this.state.lastFilterHash === currentFilterHash) {
            console.log('Filter applied too recently with same hash, skipping');
            return;
        }
        
        // SET GLOBAL LOCK to prevent other instances
        globalFilterLock = true;
        console.log('🔒 Setting GLOBAL filter lock');
        
        // Clear any existing global timeout
        if (globalFilterTimeout) {
            clearTimeout(globalFilterTimeout);
        }
        
        // Set timeout to release global lock
        globalFilterTimeout = setTimeout(() => {
            globalFilterLock = false;
            console.log('🔓 Released GLOBAL filter lock');
        }, 1000);
        
        this._lastFilterTime = now;
        
        // Apply filters immediately without debouncing
        console.log('Applying filters immediately:', this.state.filters);
        console.log('Active filters count:', this.activeFiltersCount);
        
        this.state.isFilteringInProgress = true;
        this.state.lastFilterHash = currentFilterHash;
        
        // Trigger badge animation
        this.animateFilterBadge();
        
        // Trigger filter update through parent component
        if (this.props.onFiltersChange) {
            this.props.onFiltersChange(this.state.filters);
        }
        
        // Reset filtering state after a short delay
        setTimeout(() => {
            this.state.isFilteringInProgress = false;
            
            // Release global lock
            if (globalFilterTimeout) {
                clearTimeout(globalFilterTimeout);
            }
            globalFilterLock = false;
            console.log('🔓 Released GLOBAL filter lock (filtering complete)');
            
            // Clear the hash after a delay to allow legitimate changes
            setTimeout(() => {
                this.state.lastFilterHash = null;
            }, 1000);
        }, 500);
    }
    
    getFilterHash() {
        // Create a simple hash of current filter values to detect duplicates
        const filters = this.state.filters;
        const filterString = JSON.stringify({
            search: filters.search,
            stage: filters.stage,
            farm_id: filters.farm_id,
            crop_id: filters.crop_id,
            date_from: filters.date_from,
            date_to: filters.date_to,
            status: filters.status,
            budget_min: filters.budget_min,
            budget_max: filters.budget_max,
            sort_by: filters.sort_by,
            sort_order: filters.sort_order,
            limit: filters.limit,
        });
        
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < filterString.length; i++) {
            const char = filterString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }
    
    animateFilterBadge() {
        // Animate the filter badge to show immediate feedback
        const badgeElement = document.querySelector('.badge.bg-primary');
        if (badgeElement) {
            badgeElement.classList.remove('badge-updated');
            // Force reflow to restart animation
            badgeElement.offsetHeight;
            badgeElement.classList.add('badge-updated');
            
            // Remove animation class after animation completes
            setTimeout(() => {
                badgeElement.classList.remove('badge-updated');
            }, 500);
        }
    }
    
    // Filter Persistence Methods
    saveFiltersToStorage() {
        // Save all filter values to localStorage for persistence
        const filtersToSave = {
            search: this.state.filters.search,
            stage: this.state.filters.stage,
            farm_id: this.state.filters.farm_id,
            crop_id: this.state.filters.crop_id,
            date_from: this.state.filters.date_from,
            date_to: this.state.filters.date_to,
            status: this.state.filters.status,
            budget_min: this.state.filters.budget_min,
            budget_max: this.state.filters.budget_max,
            sort_by: this.state.filters.sort_by,
            sort_order: this.state.filters.sort_order,
            limit: this.state.filters.limit,
        };
        
        localStorage.setItem('farm_dashboard_all_filters', JSON.stringify(filtersToSave));
        console.log('All filters saved to storage:', filtersToSave);
    }
    
    restoreFiltersFromStorage() {
        // Restore all filter values from localStorage
        try {
            const savedFilters = localStorage.getItem('farm_dashboard_all_filters');
            if (savedFilters) {
                const parsedFilters = JSON.parse(savedFilters);
                
                // Restore each filter value, keeping defaults if not saved
                this.state.filters.search = parsedFilters.search || '';
                this.state.filters.stage = parsedFilters.stage || '';
                this.state.filters.farm_id = parsedFilters.farm_id || '';
                this.state.filters.crop_id = parsedFilters.crop_id || '';
                this.state.filters.date_from = parsedFilters.date_from || '';
                this.state.filters.date_to = parsedFilters.date_to || '';
                this.state.filters.status = parsedFilters.status || '';
                this.state.filters.budget_min = parsedFilters.budget_min || '';
                this.state.filters.budget_max = parsedFilters.budget_max || '';
                this.state.filters.sort_by = parsedFilters.sort_by || 'start_date';
                this.state.filters.sort_order = parsedFilters.sort_order || 'desc';
                this.state.filters.limit = parsedFilters.limit || '25';
                
                console.log('All filters restored from storage:', parsedFilters);
            }
        } catch (error) {
            console.warn('Failed to restore filters from storage:', error);
            // Continue with default values if restoration fails
        }
    }
    
    debouncedFilterChange() {
        console.log('Applying filters:', this.state.filters);
        this.state.isFilteringInProgress = true;
        
        // Trigger filter update through parent component
        if (this.props.onFiltersChange) {
            this.props.onFiltersChange(this.state.filters);
        }
        
        // Reset filtering state after a short delay
        setTimeout(() => {
            this.state.isFilteringInProgress = false;
            
            // Release global lock
            if (globalFilterTimeout) {
                clearTimeout(globalFilterTimeout);
            }
            globalFilterLock = false;
            console.log('🔓 Released GLOBAL filter lock (filtering complete)');
        }, 500);
    }

    onClearFilters() {
        // Clear any pending filter timeout
        if (this.state.filterTimeout) {
            clearTimeout(this.state.filterTimeout);
            this.state.filterTimeout = null;
        }
        
        this.state.filters = {
            search: '',
            stage: '',
            farm_id: '',
            crop_id: '',
            date_from: '',
            date_to: '',
            status: '',
            budget_min: '',
            budget_max: '',
            sort_by: 'start_date',
            sort_order: 'desc',
            limit: '25',
        };
        
        // Clear all filters from localStorage
        localStorage.removeItem('farm_dashboard_all_filters');
        
        console.log('All filters cleared from state and storage');
        this.triggerFilterChange('clear-all-filters'); // Apply immediately
    }

    onSaveFilterPreset() {
        console.log('Save filter preset:', this.state.filters);
        // TODO: Implement filter preset saving
        // For now, just show a notification
        if (this.notification) {
            this.notification.add('Filter preset saved!', { type: 'success' });
        }
    }
    
    // Watch for filter changes using OWL's reactive system
    watchFilterChanges() {
        // Store previous filter values to detect changes
        this.previousFilters = { ...this.state.filters };
        
        // We'll use onWillUpdateProps or effect to watch for changes
        // For now, let's use a different approach with manual triggering
    }
    
    // Manual filter change trigger (called only when we want to apply filters)
    triggerFilterChange(source = 'manual') {
        console.log(`Filter change triggered from: ${source}`);
        
        // Handle date validation if this is a date change
        if (source.includes('date')) {
            this.validateDateRange();
        }
        
        // Check if filters actually changed
        const currentHash = this.getFilterHash();
        if (this.state.lastFilterHash === currentHash) {
            console.log('No actual filter change detected, skipping');
            return;
        }
        
        console.log('Filter change detected, applying...');
        console.log('Current filter values:', {
            farm_id: this.state.filters.farm_id,
            crop_id: this.state.filters.crop_id,
            stage: this.state.filters.stage,
            search: this.state.filters.search
        });
        this.saveFiltersToStorage();
        this.applyFiltersImmediate();
    }
    
    // Debug method to check current filter state
    logCurrentFilterState() {
        console.log('=== CURRENT FILTER STATE ===');
        console.log('Search:', this.state.filters.search);
        console.log('Stage:', this.state.filters.stage);
        console.log('Farm ID:', this.state.filters.farm_id);
        console.log('Crop ID:', this.state.filters.crop_id);
        console.log('Date From:', this.state.filters.date_from);
        console.log('Date To:', this.state.filters.date_to);
        console.log('Status:', this.state.filters.status);
        console.log('Budget Min:', this.state.filters.budget_min);
        console.log('Budget Max:', this.state.filters.budget_max);
        console.log('Sort By:', this.state.filters.sort_by);
        console.log('Sort Order:', this.state.filters.sort_order);
        console.log('Limit:', this.state.filters.limit);
        console.log('Active Filters Count:', this.activeFiltersCount);
        console.log('Has Active Filters:', this.hasActiveFilters);
        console.log('=== END FILTER STATE ===');
    }

    // ===============================
    // NEW PROJECT MODAL METHODS
    // ===============================

    onCreateProject() {
        console.log('Opening new project modal');
        this.resetNewProjectForm();
        this.state.showNewProjectModal = true;
    }

    onCloseNewProjectModal() {
        console.log('Closing new project modal');
        this.state.showNewProjectModal = false;
        this.resetNewProjectForm();
    }

    resetNewProjectForm() {
        this.state.newProject = {
            name: '',
            // code will be auto-generated by the model
            farm_id: '',
            field_id: '',
            crop_id: '',
            crop_bom_id: '',
            start_date: new Date().toISOString().split('T')[0], // Today's date
            planned_end_date: '',
            description: '',
            bomTotalCost: 0
        };
        this.state.validationErrors = {};
        this.state.savingNewProject = false;
    }

    onFarmChange() {
        // Clear field selection when farm changes
        this.state.newProject.field_id = '';
        console.log('Farm changed, cleared field selection');
    }

    onCropChange() {
        // Clear BOM selection when crop changes
        this.state.newProject.crop_bom_id = '';
        this.state.newProject.bomTotalCost = 0;
        console.log('Crop changed, cleared BOM selection');
    }

    onBomChange() {
        // Update BOM total cost when BOM changes
        if (this.state.newProject.crop_bom_id) {
            const selectedBom = this.availableCropBOMs.find(bom => bom.id == this.state.newProject.crop_bom_id);
            if (selectedBom && selectedBom.total_cost) {
                this.state.newProject.bomTotalCost = selectedBom.total_cost;
            } else {
                // For demo BOMs, use a calculated cost
                this.state.newProject.bomTotalCost = this.calculateDemoBomCost(selectedBom);
            }
        } else {
            this.state.newProject.bomTotalCost = 0;
        }
        console.log('BOM changed, updated total cost:', this.state.newProject.bomTotalCost);
    }

    calculateDemoBomCost(bom) {
        // Calculate demo BOM cost based on crop type
        if (!bom) return 0;
        
        const baseCosts = {
            'Wheat': 5000,
            'Corn': 7500, 
            'Soybeans': 4500,
            'Tomatoes': 12000
        };
        
        // Extract crop name from BOM name
        for (const [crop, cost] of Object.entries(baseCosts)) {
            if (bom.name.includes(crop)) {
                // Adjust cost based on BOM type
                if (bom.name.includes('Organic')) return cost * 1.3;
                if (bom.name.includes('High Yield')) return cost * 1.2;
                if (bom.name.includes('Greenhouse') || bom.name.includes('Hydroponic')) return cost * 1.5;
                return cost;
            }
        }
        
        return 5000; // Default cost
    }


    toggleSection(stageKey) {
        // Toggle the expanded state of a stage section
        this.state.expandedSections[stageKey] = !this.state.expandedSections[stageKey];
        console.log(`Toggled section ${stageKey} to ${this.state.expandedSections[stageKey] ? 'expanded' : 'collapsed'}`);
        
        // Save to localStorage for persistence
        this.saveExpandedSectionsToStorage();
    }

    isSectionExpanded(stageKey) {
        // Check if a stage section is expanded
        return this.state.expandedSections[stageKey] !== false; // Default to true if not set
    }

    saveExpandedSectionsToStorage() {
        try {
            localStorage.setItem('farm_dashboard_expanded_sections', JSON.stringify(this.state.expandedSections));
        } catch (e) {
            console.warn('Could not save expanded sections to localStorage:', e);
        }
    }

    restoreExpandedSectionsFromStorage() {
        try {
            const saved = localStorage.getItem('farm_dashboard_expanded_sections');
            if (saved) {
                const expandedSections = JSON.parse(saved);
                // Merge with defaults, keeping user preferences
                this.state.expandedSections = { ...this.state.expandedSections, ...expandedSections };
                console.log('Restored expanded sections from storage:', this.state.expandedSections);
            }
        } catch (e) {
            console.warn('Could not restore expanded sections from localStorage:', e);
        }
    }

    async onSaveNewProject() {
        if (this.state.savingNewProject) return;

        // Clear previous validation errors
        this.state.validationErrors = {};

        // Validate required fields and collect errors
        const errors = {};
        
        if (!this.state.newProject.name.trim()) {
            errors.name = 'Project name is required';
        }
        if (!this.state.newProject.farm_id) {
            errors.farm_id = 'Please select a farm';
        }
        if (!this.state.newProject.field_id) {
            errors.field_id = 'Please select a field';
        }
        if (!this.state.newProject.crop_id) {
            errors.crop_id = 'Please select a crop';
        }
        if (!this.state.newProject.crop_bom_id) {
            errors.crop_bom_id = 'Please select a crop BOM';
        }
        if (!this.state.newProject.start_date) {
            errors.start_date = 'Start date is required';
        }
        if (!this.state.newProject.planned_end_date) {
            errors.planned_end_date = 'Planned end date is required';
        }
        
        // Validate date logic
        if (this.state.newProject.start_date && this.state.newProject.planned_end_date) {
            const startDate = new Date(this.state.newProject.start_date);
            const endDate = new Date(this.state.newProject.planned_end_date);
            if (endDate <= startDate) {
                errors.planned_end_date = 'Planned end date must be after start date';
            }
        }

        // If there are validation errors, show them and return
        if (Object.keys(errors).length > 0) {
            this.state.validationErrors = errors;
            console.log('Validation errors found:', errors);
            this.showNotification('Please fix the validation errors below', 'error');
            return;
        }

        console.log('Validation passed, proceeding with project creation');
        this.state.savingNewProject = true;
        
        try {
            console.log('Creating new project:', this.state.newProject);
            
            // Prepare project data
            const projectData = {
                name: this.state.newProject.name.trim(),
                // code will be auto-generated by the cultivation project model
                farm_id: parseInt(this.state.newProject.farm_id),
                field_id: parseInt(this.state.newProject.field_id),
                crop_id: parseInt(this.state.newProject.crop_id),
                crop_bom_id: parseInt(this.state.newProject.crop_bom_id),
                start_date: this.state.newProject.start_date,
                planned_end_date: this.state.newProject.planned_end_date,
                description: this.state.newProject.description.trim() || null,
                state: 'draft' // New projects start in draft state
                // Note: Budget is calculated from BOM in the backend, not sent from frontend
            };

            // Call backend to create project
            const result = await this.createProject(projectData);
            
            if (result && result.success) {
                this.showNotification('Project created successfully!', 'success');
                this.onCloseNewProjectModal();
                
                // Refresh the projects data
                if (this.props.onFiltersChange) {
                    this.props.onFiltersChange(this.state.filters);
                }
            } else {
                throw new Error(result?.error || 'Failed to create project');
            }
            
        } catch (error) {
            console.error('Error creating project:', error);
            this.showNotification(error.message || 'Failed to create project', 'error');
        } finally {
            this.state.savingNewProject = false;
        }
    }

    async createProject(projectData) {
        try {
            console.log('Creating project with data:', projectData);
            
            // Use the passed rpcCall prop
            if (this.props.rpcCall) {
                console.log('Using props.rpcCall to create project');
                const result = await this.props.rpcCall(
                    'farm.dashboard.data',
                    'create_project',
                    [projectData]  // Args as array
                );
                console.log('Project creation result:', result);
                return result;
            } else {
                console.error('No rpcCall method available in props');
                throw new Error('RPC method not available');
            }
        } catch (error) {
            console.error('Error in createProject:', error);
            throw error;
        }
    }

    showNotification(message, type = 'info') {
        // Use the notification service if available
        if (this.notification) {
            this.notification.add(message, { type: type });
        } else {
            // Fallback to console and alert for important messages
            console.log(`${type.toUpperCase()}: ${message}`);
            if (type === 'error') {
                alert(`Error: ${message}`);
            }
        }
    }
}