/** @odoo-module **/

import { Component, useState, useService } from "@odoo/owl";
import { _t } from "@web/core/l10n/translation";
import { SmartButton } from "../common/smart_button";

// Global filter lock to prevent multiple instances from filtering simultaneously
let globalFilterLock = false;
let globalFilterTimeout = null;

export class ProjectsTab extends Component {
    static template = "farm_management_dashboard.ProjectsTabTemplate";
    static components = {
        SmartButton,
    };
    static props = {
        data: Object,
        filters: Object,
        userPermissions: Object,
        onFiltersChange: Function,
        rpcCall: { type: Function, optional: true },
    };

    setup() {
        // Try to use notification service
        try {
            this.notification = useService("notification");
        } catch (e) {
            console.warn("Notification service not available");
            this.notification = null;
        }
        
        
        
        
        this.state = useState({
            selectedProject: null,
            selectedProjectReports: [],
            loadingProjectDetails: false,
            
            // Filter state
            showFilters: false,
            showAdvancedFilters: false,
            filters: {
                search: '',
                stage: '',
                farm_id: '',
                crop_id: '',
                date_from: '',
                date_to: '',
                status: '',
                budget_min: '',
                budget_max: '',
                sort_by: 'start_date',
                sort_order: 'desc',
                limit: '25',
            },
            
            // Debouncing state
            filterTimeout: null,
            isFilteringInProgress: false,
            lastFilterHash: null, // To prevent duplicate filter applications
            isInitialized: false, // To prevent multiple initializations
            
            // New Project Modal state
            showNewProjectModal: false,
            savingNewProject: false,
            
            // Collapsible sections state - track which stage sections are expanded
            expandedSections: {
                // Default: expand all sections initially
                'draft': true,
                'planning': true,
                'preparation': true,
                'sowing': true,
                'growing': true,
                'harvest': true,
                'sales': true,
                'done': true,
                'cancel': false  // Keep cancelled projects collapsed by default
            },
            newProject: {
                name: '',
                // code will be auto-generated by the model
                farm_id: '',
                field_id: '',
                crop_id: '',
                crop_bom_id: '',
                start_date: '',
                planned_end_date: '',
                description: '',
                bomTotalCost: 0
            },
            validationErrors: {}
        });
        
        // Bind debounced method
        this.debouncedFilterChange = this.debouncedFilterChange.bind(this);
        
        // Watch for filter changes using OWL's reactive system
        this.watchFilterChanges();
        
        // Setup notification service
        try {
            this.notification = useService("notification");
        } catch (e) {
            console.warn("Notification service not available, using console fallback");
            this.notification = {
                add: (message, options) => console.log("Notification:", message, options)
            };
        }
        
        // Restore filter panel state from localStorage
        const savedFilterPanelState = localStorage.getItem('farm_dashboard_filters_visible');
        if (savedFilterPanelState !== null) {
            this.state.showFilters = savedFilterPanelState === 'true';
        }
        
        // Restore all filters from localStorage to preserve across tab switches
        this.restoreFiltersFromStorage();
        
        // Restore expanded sections from localStorage
        this.restoreExpandedSectionsFromStorage();
        
        // DISABLED: No automatic filter application on component initialization
        // This was causing multiple instances to apply filters simultaneously
        console.log('Component initialized - filters will only be applied manually via "Apply Filters" button');
    }

    get stats() {
        return this.props.data.stats || {
            total_projects: 0,
            active_projects: 0,
            total_area: 0,
            total_budget: 0
        };
    }

    get projectsByStage() {
        const projectsData = this.props.data.projects_by_stage || {};
        console.log('ðŸ”§ ProjectsTab: Projects data structure:', projectsData);
        console.log('ðŸ”§ ProjectsTab: Projects data keys:', Object.keys(projectsData));
        
        // Log first project details if available
        const firstStage = Object.keys(projectsData)[0];
        if (firstStage && projectsData[firstStage] && projectsData[firstStage].length > 0) {
            console.log('ðŸ”§ ProjectsTab: First project details:', projectsData[firstStage][0]);
            console.log('ðŸ”§ ProjectsTab: First project ID:', projectsData[firstStage][0].id);
            console.log('ðŸ”§ ProjectsTab: First project ID type:', typeof projectsData[firstStage][0].id);
        }
        
        return Object.entries(projectsData).sort(([stageA], [stageB]) => {
            // Sort stages in logical order
            const stageOrder = {
                'draft': 1, 'planning': 2, 'growing': 3, 'harvest': 4, 
                'sales': 5, 'completed': 6, 'cancelled': 7
            };
            return (stageOrder[stageA] || 99) - (stageOrder[stageB] || 99);
        });
    }

    get hasProjects() {
        return this.stats.total_projects > 0;
    }

    get lastUpdated() {
        return this.props.data.last_updated || '';
    }

    // Quick Actions for Projects Tab
    get quickActions() {
        console.log('ðŸ”§ Generating quick actions for projects tab');
        const actions = [
            { icon: 'fa-plus-circle', label: 'New Project', type: 'primary', size: 'sm', action: 'farm.cultivation.project' },
            { icon: 'fa-seedling', label: 'Active Projects', type: 'success', size: 'sm', action: 'farm.cultivation.project' },
            { icon: 'fa-clipboard-list', label: 'Daily Reports', type: 'primary', size: 'sm', action: 'farm.daily.report' },
            { icon: 'fa-home', label: 'Manage Farms', type: 'secondary', size: 'sm', action: 'farm.farm' },
            { icon: 'fa-map', label: 'Manage Fields', type: 'secondary', size: 'sm', action: 'farm.field' }
        ];
        console.log('ðŸ”§ Generated quick actions:', actions);
        return actions;
    }

    get smartActions() {
        const actions = [];
        
        // Add smart actions based on project data
        if (this.props.data?.projects_by_stage) {
            const stages = this.props.data.projects_by_stage;
            
            // Check for projects in planning stage
            if (stages.planning && stages.planning.length > 0) {
                actions.push({
                    icon: 'fa-calendar-check',
                    label: 'Planning Projects',
                    type: 'info',
                    size: 'sm',
                    badge: stages.planning.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for projects in growing stage
            if (stages.growing && stages.growing.length > 0) {
                actions.push({
                    icon: 'fa-leaf',
                    label: 'Growing Projects',
                    type: 'success',
                    size: 'sm',
                    badge: stages.growing.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for projects in harvest stage
            if (stages.harvest && stages.harvest.length > 0) {
                actions.push({
                    icon: 'fa-cut',
                    label: 'Harvest Projects',
                    type: 'warning',
                    size: 'sm',
                    badge: stages.harvest.length,
                    action: 'farm.cultivation.project'
                });
            }
            
            // Check for overdue projects (projects past planned end date)
            const now = new Date();
            let overdueCount = 0;
            Object.values(stages).forEach(projects => {
                if (Array.isArray(projects)) {
                    projects.forEach(project => {
                        if (project.planned_end_date && new Date(project.planned_end_date) < now) {
                            overdueCount++;
                        }
                    });
                }
            });
            
            if (overdueCount > 0) {
                actions.push({
                    icon: 'fa-exclamation-triangle',
                    label: 'Overdue Projects',
                    type: 'danger',
                    size: 'sm',
                    badge: overdueCount,
                    action: 'farm.cultivation.project',
                    // Store filter info for custom handling
                    filterInfo: {
                        domain: [['planned_end_date', '<', new Date().toISOString().split('T')[0]]],
                        context: { 'search_default_overdue': 1 }
                    }
                });
            }
        }
        
        console.log('ðŸ”§ Generated smart actions:', actions);
        return actions;
    }

    // Filter-related getters
    get showFilters() {
        return this.state.showFilters;
    }

    get showAdvancedFilters() {
        return this.state.showAdvancedFilters;
    }

    get filters() {
        return this.state.filters;
    }

    get hasActiveFilters() {
        const filters = this.state.filters;
        return !!((filters.search && filters.search.trim()) || filters.stage || filters.farm_id || 
                 filters.crop_id || filters.date_from || filters.date_to || 
                 filters.status || filters.budget_min || filters.budget_max);
    }

    get activeFiltersCount() {
        let count = 0;
        const filters = this.state.filters;
        
        if (filters.search && filters.search.trim()) count++;
        if (filters.stage) count++;
        if (filters.farm_id) count++;
        if (filters.crop_id) count++;
        if (filters.date_from || filters.date_to) count++;
        if (filters.status) count++;
        if (filters.budget_min || filters.budget_max) count++;
        
        // Debug logging for badge updates (only when count changes)
        if (this._lastBadgeCount !== count) {
            console.log('Badge count updated:', this._lastBadgeCount, '->', count);
            this._lastBadgeCount = count;
        }
        
        return count;
    }

    get filteredProjectsCount() {
        // Return the filtered count from backend data if available
        return this.props.data.filtered_count || this.stats.total_projects;
    }

    get availableFarms() {
        // Use complete list from backend data (not filtered by current projects)
        return this.props.data.available_farms || [];
    }

    get availableCrops() {
        // Use complete list from backend data (not filtered by current projects)
        return this.props.data.available_crops || [];
    }

    get availableFields() {
        // Return fields for the selected farm
        if (!this.state.newProject.farm_id) {
            return [];
        }
        
        const farmId = parseInt(this.state.newProject.farm_id);
        const allFields = this.props.data.available_fields || [];
        
        return allFields.filter(field => field.farm_id === farmId);
    }

    get availableCropBOMs() {
        // Return BOMs for the selected crop
        if (!this.state.newProject.crop_id) {
            return [];
        }
        
        const cropId = parseInt(this.state.newProject.crop_id);
        const allBOMs = this.props.data.available_crop_boms || [];
        
        return allBOMs.filter(bom => bom.crop_id === cropId);
    }

    // Formatting methods
    formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(amount || 0);
    }

    formatNumber(number) {
        return new Intl.NumberFormat('en-US').format(number || 0);
    }

    formatDate(dateString) {
        if (!dateString) return '';
        return new Date(dateString).toLocaleDateString();
    }

    formatDateTime(dateTimeString) {
        if (!dateTimeString) return '';
        return new Date(dateTimeString).toLocaleString();
    }

    // Stage helper methods
    getStageLabel(stage) {
        const stageLabels = {
            'draft': 'Draft',
            'planning': 'Planning',
            'preparation': 'Field Preparation',  // ACTIVE
            'sowing': 'Planting/Sowing',         // ACTIVE
            'growing': 'Growing',                // ACTIVE
            'harvest': 'Harvest',               // ACTIVE
            'sales': 'Sales',                   // ACTIVE
            'done': 'Completed',
            'cancel': 'Cancelled'
        };
        return stageLabels[stage] || stage.charAt(0).toUpperCase() + stage.slice(1);
    }

    getStageIcon(stage) {
        const stageIcons = {
            'draft': 'fa fa-edit text-secondary',
            'planning': 'fa fa-calendar-alt text-primary',
            'preparation': 'fa fa-tractor text-warning',     // Field Preparation - ACTIVE
            'sowing': 'fa fa-seedling text-primary',         // Planting/Sowing - ACTIVE
            'growing': 'fa fa-leaf text-success',            // Growing - ACTIVE
            'harvest': 'fa fa-cut text-warning',             // Harvest - ACTIVE
            'sales': 'fa fa-shopping-cart text-info',        // Sales - ACTIVE
            'done': 'fa fa-check-circle text-success',       // Completed
            'cancel': 'fa fa-times-circle text-danger'       // Cancelled
        };
        return stageIcons[stage] || 'fa fa-circle text-muted';
    }

    getStageColor(stage) {
        const stageColors = {
            'draft': 'secondary',
            'planning': 'primary',
            'preparation': 'warning',     // Field Preparation - ACTIVE (Orange)
            'sowing': 'primary',          // Planting/Sowing - ACTIVE (Blue)
            'growing': 'success',         // Growing - ACTIVE (Green)
            'harvest': 'warning',         // Harvest - ACTIVE (Orange)
            'sales': 'info',              // Sales - ACTIVE (Light Blue)
            'done': 'success',            // Completed (Green)
            'cancel': 'danger'            // Cancelled (Red)
        };
        return stageColors[stage] || 'muted';
    }

    // Progress calculation - matches backend logic
    calculateProgress(project) {
        // State-based progress calculation matching backend
        const progressByStage = {
            'draft': 0,
            'planning': 10,
            'preparation': 20,  // Field Preparation - ACTIVE
            'sowing': 35,       // Planting/Sowing - ACTIVE
            'growing': 60,      // Growing - ACTIVE
            'harvest': 80,      // Harvest - ACTIVE
            'sales': 95,        // Sales - ACTIVE
            'done': 100,        // Completed
            'cancel': 0         // Cancelled
        };
        return progressByStage[project.state] || 0;
    }

    get selectedProject() {
        return this.state.selectedProject;
    }

    get selectedProjectReports() {
        return this.state.selectedProjectReports;
    }

    // Action handlers
    async onViewProject(projectId) {
        console.log('View project:', projectId);
        
        // Find the project in the current data
        let project = null;
        for (const [stage, projects] of this.projectsByStage) {
            project = projects.find(p => p.id === projectId);
            if (project) break;
        }
        
        if (!project) {
            console.error('Project not found:', projectId);
            return;
        }
        
        // Set selected project
        this.state.selectedProject = project;
        this.state.loadingProjectDetails = true;
        
        try {
            // TODO: Load project reports from backend
            // For now, use mock data
            this.state.selectedProjectReports = [
                {
                    id: 1,
                    operation_type: 'Planting',
                    description: 'Planted seeds in designated areas',
                    date: '2025-01-20',
                },
                {
                    id: 2,
                    operation_type: 'Watering',
                    description: 'Irrigation system maintenance and watering',
                    date: '2025-02-15',
                },
                {
                    id: 3,
                    operation_type: 'Fertilizing',
                    description: 'Applied organic fertilizer',
                    date: '2025-03-10',
                }
            ];
        } catch (error) {
            console.error('Error loading project details:', error);
            this.state.selectedProjectReports = [];
        } finally {
            this.state.loadingProjectDetails = false;
        }
    }

    onCloseProjectDetail() {
        this.state.selectedProject = null;
        this.state.selectedProjectReports = [];
    }

    onViewProjectDetails(projectId) {
        console.log('View project details:', projectId);
        console.log('Project ID type:', typeof projectId);
        console.log('Project ID value:', projectId);
        
        // Debug: Check if projectId is valid
        if (!projectId || projectId === undefined || projectId === null) {
            console.error('âŒ Project ID is invalid:', projectId);
            this.showNotification('Invalid project ID', 'error');
            return;
        }
        
        // Open project form view
        this.navigateToProject(projectId, 'form');
    }

    onEditProject(projectId) {
        console.log('Edit project:', projectId);
        console.log('Edit Project ID type:', typeof projectId);
        console.log('Edit Project ID value:', projectId);
        
        // Debug: Check if projectId is valid
        if (!projectId || projectId === undefined || projectId === null) {
            console.error('âŒ Edit Project ID is invalid:', projectId);
            this.showNotification('Invalid project ID for editing', 'error');
            return;
        }
        
        // Open project form view in edit mode
        this.navigateToProject(projectId, 'form', { 'default_mode': 'edit' });
    }

    onViewProjectReports(projectId) {
        console.log('View project reports:', projectId);
        console.log('Reports Project ID type:', typeof projectId);
        console.log('Reports Project ID value:', projectId);
        
        // Debug: Check if projectId is valid
        if (!projectId || projectId === undefined || projectId === null) {
            console.error('âŒ Reports Project ID is invalid:', projectId);
            this.showNotification('Invalid project ID for reports', 'error');
            return;
        }
        
        // Open daily reports filtered by project
        this.navigateToProjectReports(projectId);
    }

    async navigateToProject(projectId, viewMode = 'form', context = {}) {
        console.log('ðŸ”§ ProjectsTab: Project navigation requested:', projectId, viewMode);
        this.showNotification(`Project ${projectId} - ${viewMode} view`, 'info');
    }

    async navigateToProjectReports(projectId) {
        console.log('ðŸ”§ ProjectsTab: Reports navigation requested:', projectId);
        this.showNotification(`Project ${projectId} reports`, 'info');
    }

    onCreateProject() {
        console.log('Create new project');
        // TODO: Implement project creation form
    }

    // Filter event handlers
    onToggleFilters() {
        this.state.showFilters = !this.state.showFilters;
        console.log('Filter panel toggled:', this.state.showFilters);
        
        // Store filter panel state in localStorage to persist across refreshes
        localStorage.setItem('farm_dashboard_filters_visible', this.state.showFilters);
    }

    onToggleAdvancedFilters() {
        this.state.showAdvancedFilters = !this.state.showAdvancedFilters;
        console.log('Advanced filters toggled:', this.state.showAdvancedFilters);
    }

    onSearchInputChange() {
        // Only update the UI state, don't trigger filtering yet
        console.log('Search input changed to:', this.state.filters.search, '- waiting for trigger...');
    }
    
    onSearchTrigger() {
        // Only trigger search if there's actual content (not empty or just whitespace)
        const searchTerm = this.state.filters.search.trim();
        
        if (searchTerm === '') {
            console.log('Search skipped: empty or blank search term');
            // If search is cleared, apply filters to remove search filter
            this.clearSearchFilter();
            return;
        }
        
        // Update the search filter with the trimmed value to ensure consistency
        this.state.filters.search = searchTerm;
        
        // Save all filters to localStorage to preserve across tab switches and refreshes
        this.saveFiltersToStorage();
        
        console.log('Search triggered and all filters saved:', searchTerm);
        console.log('Badge will update - Active filters:', this.activeFiltersCount);
        
        // Debug: Log current filter state
        this.logCurrentFilterState();
        
        this.triggerFilterChange('search-trigger');
    }
    
    clearSearchFilter() {
        // Clear search filter but keep other filters intact
        console.log('Clearing search filter while preserving other filters');
        this.state.filters.search = '';
        
        // Save all filters to localStorage (with search cleared)
        this.saveFiltersToStorage();
        
        this.triggerFilterChange('clear-search');
    }
    
    onSearchKeyPress(event) {
        // Trigger search on Enter key
        if (event.key === 'Enter') {
            console.log('Search triggered by Enter key - using manual trigger');
            this.triggerFilterChange('search-enter');
        }
    }
    
    onDropdownFilterChange() {
        // For dropdowns - apply with a tiny delay to prevent rapid-fire events
        console.log('Dropdown filter changed, applying with small delay');
        
        // Use a more aggressive debouncing approach for dropdowns
        this.debouncedDropdownChange();
    }
    
    debouncedDropdownChange() {
        // Clear any existing timeout
        if (this.state.filterTimeout) {
            clearTimeout(this.state.filterTimeout);
        }
        
        // Prevent multiple rapid filter applications
        if (this.state.isFilteringInProgress) {
            console.log('Filter already in progress, scheduling for later');
            // Schedule for after current operation completes
            this.state.filterTimeout = setTimeout(() => {
                this.debouncedDropdownChange();
            }, 600);
            return;
        }
        
        // Apply filter with a small delay to prevent multiple rapid changes
        this.state.filterTimeout = setTimeout(() => {
            console.log('Applying debounced dropdown filter change');
            console.log('Badge will update - Active filters:', this.activeFiltersCount);
            
            // Save all filters to localStorage to preserve dropdown selections
            this.saveFiltersToStorage();
            this.applyFiltersImmediate();
        }, 150); // Small delay to debounce rapid dropdown changes
    }
    
    onDateFilterChange() {
        // For date inputs - validate and apply immediately
        this.validateDateRange();
        console.log('Date filter changed - Active filters:', this.activeFiltersCount);
        
        // Prevent multiple rapid filter applications
        if (this.state.isFilteringInProgress) {
            console.log('Date filter already in progress, skipping duplicate request');
            return;
        }
        
        // Save all filters to localStorage to preserve date selections
        this.saveFiltersToStorage();
        
        this.applyFiltersImmediate();
    }
    
    onBudgetInputChange() {
        // Only update the UI state, don't trigger filtering yet
        console.log('Budget input changed, waiting for focus loss or enter...');
    }
    
    onBudgetTrigger() {
        // Trigger budget filter only on enter key (not focus loss)
        // Allow empty budget values (they represent "no limit")
        console.log('Budget filter triggered');
        
        // Save all filters to localStorage to preserve budget values
        this.saveFiltersToStorage();
        
        this.triggerFilterChange('budget-trigger');
    }
    
    onBudgetKeyPress(event) {
        // Trigger budget filter on Enter key
        if (event.key === 'Enter') {
            console.log('Budget filter triggered by Enter key - using manual trigger');
            this.triggerFilterChange('budget-enter');
        }
    }
    
    validateDateRange() {
        const { date_from, date_to } = this.state.filters;
        
        if (date_from && date_to) {
            const startDate = new Date(date_from);
            const endDate = new Date(date_to);
            
            if (endDate < startDate) {
                // Auto-correct: set end date to start date
                this.state.filters.date_to = date_from;
                console.log('Date range corrected: end date set to start date');
                
                // Show user notification
                if (this.notification) {
                    this.notification.add('End date adjusted to match start date', { 
                        type: 'info',
                        title: 'Date Range Correction'
                    });
                }
            }
        }
    }
    
    applyFiltersImmediate() {
        // GLOBAL filter lock - prevent ALL instances from filtering simultaneously
        if (globalFilterLock) {
            console.log('ðŸ”’ GLOBAL filter lock active, ignoring duplicate call from any instance');
            return;
        }
        
        // AGGRESSIVE duplicate prevention - check if we're already filtering
        if (this.state.isFilteringInProgress) {
            console.log('Filter already in progress, ignoring duplicate call');
            return;
        }
        
        // Create a hash of current filters to prevent duplicate applications
        const currentFilterHash = this.getFilterHash();
        
        // Check if this is a duplicate filter application
        if (this.state.lastFilterHash === currentFilterHash) {
            console.log('Duplicate filter application detected (same hash), skipping');
            return;
        }
        
        // Check if we applied this exact same filter very recently (within 500ms)
        const now = Date.now();
        if (this._lastFilterTime && (now - this._lastFilterTime) < 500 && this.state.lastFilterHash === currentFilterHash) {
            console.log('Filter applied too recently with same hash, skipping');
            return;
        }
        
        // SET GLOBAL LOCK to prevent other instances
        globalFilterLock = true;
        console.log('ðŸ”’ Setting GLOBAL filter lock');
        
        // Clear any existing global timeout
        if (globalFilterTimeout) {
            clearTimeout(globalFilterTimeout);
        }
        
        // Set timeout to release global lock
        globalFilterTimeout = setTimeout(() => {
            globalFilterLock = false;
            console.log('ðŸ”“ Released GLOBAL filter lock');
        }, 1000);
        
        this._lastFilterTime = now;
        
        // Apply filters immediately without debouncing
        console.log('Applying filters immediately:', this.state.filters);
        console.log('Active filters count:', this.activeFiltersCount);
        
        this.state.isFilteringInProgress = true;
        this.state.lastFilterHash = currentFilterHash;
        
        // Trigger badge animation
        this.animateFilterBadge();
        
        // Trigger filter update through parent component
        if (this.props.onFiltersChange) {
            this.props.onFiltersChange(this.state.filters);
        }
        
        // Reset filtering state after a short delay
        setTimeout(() => {
            this.state.isFilteringInProgress = false;
            
            // Release global lock
            if (globalFilterTimeout) {
                clearTimeout(globalFilterTimeout);
            }
            globalFilterLock = false;
            console.log('ðŸ”“ Released GLOBAL filter lock (filtering complete)');
            
            // Clear the hash after a delay to allow legitimate changes
            setTimeout(() => {
                this.state.lastFilterHash = null;
            }, 1000);
        }, 500);
    }
    
    getFilterHash() {
        // Create a simple hash of current filter values to detect duplicates
        const filters = this.state.filters;
        const filterString = JSON.stringify({
            search: filters.search,
            stage: filters.stage,
            farm_id: filters.farm_id,
            crop_id: filters.crop_id,
            date_from: filters.date_from,
            date_to: filters.date_to,
            status: filters.status,
            budget_min: filters.budget_min,
            budget_max: filters.budget_max,
            sort_by: filters.sort_by,
            sort_order: filters.sort_order,
            limit: filters.limit,
        });
        
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < filterString.length; i++) {
            const char = filterString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }
    
    animateFilterBadge() {
        // Animate the filter badge to show immediate feedback
        const badgeElement = document.querySelector('.badge.bg-primary');
        if (badgeElement) {
            badgeElement.classList.remove('badge-updated');
            // Force reflow to restart animation
            badgeElement.offsetHeight;
            badgeElement.classList.add('badge-updated');
            
            // Remove animation class after animation completes
            setTimeout(() => {
                badgeElement.classList.remove('badge-updated');
            }, 500);
        }
    }
    
    // Filter Persistence Methods
    saveFiltersToStorage() {
        // Save all filter values to localStorage for persistence
        const filtersToSave = {
            search: this.state.filters.search,
            stage: this.state.filters.stage,
            farm_id: this.state.filters.farm_id,
            crop_id: this.state.filters.crop_id,
            date_from: this.state.filters.date_from,
            date_to: this.state.filters.date_to,
            status: this.state.filters.status,
            budget_min: this.state.filters.budget_min,
            budget_max: this.state.filters.budget_max,
            sort_by: this.state.filters.sort_by,
            sort_order: this.state.filters.sort_order,
            limit: this.state.filters.limit,
        };
        
        localStorage.setItem('farm_dashboard_all_filters', JSON.stringify(filtersToSave));
        console.log('All filters saved to storage:', filtersToSave);
    }
    
    restoreFiltersFromStorage() {
        // Restore all filter values from localStorage
        try {
            const savedFilters = localStorage.getItem('farm_dashboard_all_filters');
            if (savedFilters) {
                const parsedFilters = JSON.parse(savedFilters);
                
                // Restore each filter value, keeping defaults if not saved
                this.state.filters.search = parsedFilters.search || '';
                this.state.filters.stage = parsedFilters.stage || '';
                this.state.filters.farm_id = parsedFilters.farm_id || '';
                this.state.filters.crop_id = parsedFilters.crop_id || '';
                this.state.filters.date_from = parsedFilters.date_from || '';
                this.state.filters.date_to = parsedFilters.date_to || '';
                this.state.filters.status = parsedFilters.status || '';
                this.state.filters.budget_min = parsedFilters.budget_min || '';
                this.state.filters.budget_max = parsedFilters.budget_max || '';
                this.state.filters.sort_by = parsedFilters.sort_by || 'start_date';
                this.state.filters.sort_order = parsedFilters.sort_order || 'desc';
                this.state.filters.limit = parsedFilters.limit || '25';
                
                console.log('All filters restored from storage:', parsedFilters);
            }
        } catch (error) {
            console.warn('Failed to restore filters from storage:', error);
            // Continue with default values if restoration fails
        }
    }
    
    debouncedFilterChange() {
        console.log('Applying filters:', this.state.filters);
        this.state.isFilteringInProgress = true;
        
        // Trigger filter update through parent component
        if (this.props.onFiltersChange) {
            this.props.onFiltersChange(this.state.filters);
        }
        
        // Reset filtering state after a short delay
        setTimeout(() => {
            this.state.isFilteringInProgress = false;
            
            // Release global lock
            if (globalFilterTimeout) {
                clearTimeout(globalFilterTimeout);
            }
            globalFilterLock = false;
            console.log('ðŸ”“ Released GLOBAL filter lock (filtering complete)');
        }, 500);
    }

    onClearFilters() {
        // Clear any pending filter timeout
        if (this.state.filterTimeout) {
            clearTimeout(this.state.filterTimeout);
            this.state.filterTimeout = null;
        }
        
        this.state.filters = {
            search: '',
            stage: '',
            farm_id: '',
            crop_id: '',
            date_from: '',
            date_to: '',
            status: '',
            budget_min: '',
            budget_max: '',
            sort_by: 'start_date',
            sort_order: 'desc',
            limit: '25',
        };
        
        // Clear all filters from localStorage
        localStorage.removeItem('farm_dashboard_all_filters');
        
        console.log('All filters cleared from state and storage');
        this.triggerFilterChange('clear-all-filters'); // Apply immediately
    }

    onSaveFilterPreset() {
        console.log('Save filter preset:', this.state.filters);
        // TODO: Implement filter preset saving
        // For now, just show a notification
        if (this.notification) {
            this.notification.add('Filter preset saved!', { type: 'success' });
        }
    }
    
    // Watch for filter changes using OWL's reactive system
    watchFilterChanges() {
        // Store previous filter values to detect changes
        this.previousFilters = { ...this.state.filters };
        
        // We'll use onWillUpdateProps or effect to watch for changes
        // For now, let's use a different approach with manual triggering
    }
    
    // Manual filter change trigger (called only when we want to apply filters)
    triggerFilterChange(source = 'manual') {
        console.log(`Filter change triggered from: ${source}`);
        
        // Handle date validation if this is a date change
        if (source.includes('date')) {
            this.validateDateRange();
        }
        
        // Check if filters actually changed
        const currentHash = this.getFilterHash();
        if (this.state.lastFilterHash === currentHash) {
            console.log('No actual filter change detected, skipping');
            return;
        }
        
        console.log('Filter change detected, applying...');
        console.log('Current filter values:', {
            farm_id: this.state.filters.farm_id,
            crop_id: this.state.filters.crop_id,
            stage: this.state.filters.stage,
            search: this.state.filters.search
        });
        this.saveFiltersToStorage();
        this.applyFiltersImmediate();
    }
    
    // Debug method to check current filter state
    logCurrentFilterState() {
        console.log('=== CURRENT FILTER STATE ===');
        console.log('Search:', this.state.filters.search);
        console.log('Stage:', this.state.filters.stage);
        console.log('Farm ID:', this.state.filters.farm_id);
        console.log('Crop ID:', this.state.filters.crop_id);
        console.log('Date From:', this.state.filters.date_from);
        console.log('Date To:', this.state.filters.date_to);
        console.log('Status:', this.state.filters.status);
        console.log('Budget Min:', this.state.filters.budget_min);
        console.log('Budget Max:', this.state.filters.budget_max);
        console.log('Sort By:', this.state.filters.sort_by);
        console.log('Sort Order:', this.state.filters.sort_order);
        console.log('Limit:', this.state.filters.limit);
        console.log('Active Filters Count:', this.activeFiltersCount);
        console.log('Has Active Filters:', this.hasActiveFilters);
        console.log('=== END FILTER STATE ===');
    }

    // ===============================
    // NEW PROJECT MODAL METHODS
    // ===============================

    onCreateProject() {
        console.log('Opening new project modal');
        this.resetNewProjectForm();
        this.state.showNewProjectModal = true;
    }

    onCloseNewProjectModal() {
        console.log('Closing new project modal');
        this.state.showNewProjectModal = false;
        this.resetNewProjectForm();
    }

    resetNewProjectForm() {
        this.state.newProject = {
            name: '',
            // code will be auto-generated by the model
            farm_id: '',
            field_id: '',
            crop_id: '',
            crop_bom_id: '',
            start_date: new Date().toISOString().split('T')[0], // Today's date
            planned_end_date: '',
            description: '',
            bomTotalCost: 0
        };
        this.state.validationErrors = {};
        this.state.savingNewProject = false;
    }

    onFarmChange() {
        // Clear field selection when farm changes
        this.state.newProject.field_id = '';
        console.log('Farm changed, cleared field selection');
    }

    onCropChange() {
        // Clear BOM selection when crop changes
        this.state.newProject.crop_bom_id = '';
        this.state.newProject.bomTotalCost = 0;
        console.log('Crop changed, cleared BOM selection');
    }

    onBomChange() {
        // Update BOM total cost when BOM changes
        if (this.state.newProject.crop_bom_id) {
            const selectedBom = this.availableCropBOMs.find(bom => bom.id == this.state.newProject.crop_bom_id);
            if (selectedBom && selectedBom.total_cost) {
                this.state.newProject.bomTotalCost = selectedBom.total_cost;
            } else {
                // For demo BOMs, use a calculated cost
                this.state.newProject.bomTotalCost = this.calculateDemoBomCost(selectedBom);
            }
        } else {
            this.state.newProject.bomTotalCost = 0;
        }
        console.log('BOM changed, updated total cost:', this.state.newProject.bomTotalCost);
    }

    calculateDemoBomCost(bom) {
        // Calculate demo BOM cost based on crop type
        if (!bom) return 0;
        
        const baseCosts = {
            'Wheat': 5000,
            'Corn': 7500, 
            'Soybeans': 4500,
            'Tomatoes': 12000
        };
        
        // Extract crop name from BOM name
        for (const [crop, cost] of Object.entries(baseCosts)) {
            if (bom.name.includes(crop)) {
                // Adjust cost based on BOM type
                if (bom.name.includes('Organic')) return cost * 1.3;
                if (bom.name.includes('High Yield')) return cost * 1.2;
                if (bom.name.includes('Greenhouse') || bom.name.includes('Hydroponic')) return cost * 1.5;
                return cost;
            }
        }
        
        return 5000; // Default cost
    }

    formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2
        }).format(amount || 0);
    }

    toggleSection(stageKey) {
        // Toggle the expanded state of a stage section
        this.state.expandedSections[stageKey] = !this.state.expandedSections[stageKey];
        console.log(`Toggled section ${stageKey} to ${this.state.expandedSections[stageKey] ? 'expanded' : 'collapsed'}`);
        
        // Save to localStorage for persistence
        this.saveExpandedSectionsToStorage();
    }

    isSectionExpanded(stageKey) {
        // Check if a stage section is expanded
        return this.state.expandedSections[stageKey] !== false; // Default to true if not set
    }

    saveExpandedSectionsToStorage() {
        try {
            localStorage.setItem('farm_dashboard_expanded_sections', JSON.stringify(this.state.expandedSections));
        } catch (e) {
            console.warn('Could not save expanded sections to localStorage:', e);
        }
    }

    restoreExpandedSectionsFromStorage() {
        try {
            const saved = localStorage.getItem('farm_dashboard_expanded_sections');
            if (saved) {
                const expandedSections = JSON.parse(saved);
                // Merge with defaults, keeping user preferences
                this.state.expandedSections = { ...this.state.expandedSections, ...expandedSections };
                console.log('Restored expanded sections from storage:', this.state.expandedSections);
            }
        } catch (e) {
            console.warn('Could not restore expanded sections from localStorage:', e);
        }
    }

    async onSaveNewProject() {
        if (this.state.savingNewProject) return;

        // Clear previous validation errors
        this.state.validationErrors = {};

        // Validate required fields and collect errors
        const errors = {};
        
        if (!this.state.newProject.name.trim()) {
            errors.name = 'Project name is required';
        }
        if (!this.state.newProject.farm_id) {
            errors.farm_id = 'Please select a farm';
        }
        if (!this.state.newProject.field_id) {
            errors.field_id = 'Please select a field';
        }
        if (!this.state.newProject.crop_id) {
            errors.crop_id = 'Please select a crop';
        }
        if (!this.state.newProject.crop_bom_id) {
            errors.crop_bom_id = 'Please select a crop BOM';
        }
        if (!this.state.newProject.start_date) {
            errors.start_date = 'Start date is required';
        }
        if (!this.state.newProject.planned_end_date) {
            errors.planned_end_date = 'Planned end date is required';
        }
        
        // Validate date logic
        if (this.state.newProject.start_date && this.state.newProject.planned_end_date) {
            const startDate = new Date(this.state.newProject.start_date);
            const endDate = new Date(this.state.newProject.planned_end_date);
            if (endDate <= startDate) {
                errors.planned_end_date = 'Planned end date must be after start date';
            }
        }

        // If there are validation errors, show them and return
        if (Object.keys(errors).length > 0) {
            this.state.validationErrors = errors;
            console.log('Validation errors found:', errors);
            this.showNotification('Please fix the validation errors below', 'error');
            return;
        }

        console.log('Validation passed, proceeding with project creation');
        this.state.savingNewProject = true;
        
        try {
            console.log('Creating new project:', this.state.newProject);
            
            // Prepare project data
            const projectData = {
                name: this.state.newProject.name.trim(),
                // code will be auto-generated by the cultivation project model
                farm_id: parseInt(this.state.newProject.farm_id),
                field_id: parseInt(this.state.newProject.field_id),
                crop_id: parseInt(this.state.newProject.crop_id),
                crop_bom_id: parseInt(this.state.newProject.crop_bom_id),
                start_date: this.state.newProject.start_date,
                planned_end_date: this.state.newProject.planned_end_date,
                description: this.state.newProject.description.trim() || null,
                state: 'draft' // New projects start in draft state
                // Note: Budget is calculated from BOM in the backend, not sent from frontend
            };

            // Call backend to create project
            const result = await this.createProject(projectData);
            
            if (result && result.success) {
                this.showNotification('Project created successfully!', 'success');
                this.onCloseNewProjectModal();
                
                // Refresh the projects data
                if (this.props.onFiltersChange) {
                    this.props.onFiltersChange(this.state.filters);
                }
            } else {
                throw new Error(result?.error || 'Failed to create project');
            }
            
        } catch (error) {
            console.error('Error creating project:', error);
            this.showNotification(error.message || 'Failed to create project', 'error');
        } finally {
            this.state.savingNewProject = false;
        }
    }

    async createProject(projectData) {
        try {
            console.log('Creating project with data:', projectData);
            
            // Use the passed rpcCall prop
            if (this.props.rpcCall) {
                console.log('Using props.rpcCall to create project');
                const result = await this.props.rpcCall(
                    'farm.dashboard.data',
                    'create_project',
                    [projectData]  // Args as array
                );
                console.log('Project creation result:', result);
                return result;
            } else {
                console.error('No rpcCall method available in props');
                throw new Error('RPC method not available');
            }
        } catch (error) {
            console.error('Error in createProject:', error);
            throw error;
        }
    }

    showNotification(message, type = 'info') {
        // Use the notification service if available
        if (this.notification) {
            this.notification.add(message, { type: type });
        } else {
            // Fallback to console and alert for important messages
            console.log(`${type.toUpperCase()}: ${message}`);
            if (type === 'error') {
                alert(`Error: ${message}`);
            }
        }
    }
}